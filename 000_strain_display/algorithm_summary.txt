TITLE: Displacement Heatmaps on Reference vs Deformed Images (MATLAB)
VERSION: 1.0
AUTHOR: <you>
DATE: 2025-10-12

PURPOSE

Provide a robust, modifiable specification for rendering dense displacement fields (U, V) as heatmaps either:
A) On the reference image / grid (“reference domain” rendering), or
B) On the deformed image / grid (“deformed domain” rendering).

Handle large matrices (≈1000×1000), internal NaN holes, and performance trade-offs.

Serve as a blueprint for an AI agent to implement/modify MATLAB functions.

INPUT DEFINITIONS

I_ref (optional): reference image at time t0 (HxW or HxWxC).

I_def (optional): deformed image at time t1 (HxW or HxWxC).

X_ref, Y_ref (HxW, double):

Pixel coordinates for a regular grid (neighbors differ by 1).

NaN locations indicate pixels not in ROI (including internal “holes”).

U, V (HxW, double):

Displacement at each valid pixel (NaN outside ROI).

Convention: X_def = X_ref + U, Y_def = Y_ref + V (pixel units).

All matrices X_ref, Y_ref, U, V have identical sizes.

Note: If I_ref/I_def absent, only heatmaps will be rendered over empty axes with correct coordinates.

GLOBAL ASSUMPTIONS

Image coordinate system: origin near top-left; y-axis down.

X_ref, Y_ref are already in pixel coordinates; adjacent valid neighbors differ by 1.

NaN in X_ref/Y_ref/U/V means not in ROI.

Displacements are not extreme enough to cause large-scale folding across the entire ROI
(local folding may still occur; see section 8).

OUTPUTS

Figures/axes with heatmaps for U and V:

On reference domain (aligned to reference pixel coordinates).

On deformed domain (aligned to deformed pixel coordinates; optionally overlaid on I_def).

Optional overlays: ROI boundaries, unified color scale for U/V.

RENDERING ON REFERENCE IMAGE (REFERENCE DOMAIN)

4.1 Goal

Plot U and V heatmaps on the undeformed grid (reference coordinates).

Grid is regular; use imagesc with AlphaData to hide NaNs/holes.

4.2 Algorithm (Reference)

Build ROI mask:
ROI = ~isnan(X_ref) & ~isnan(Y_ref) & ~isnan(U) & ~isnan(V).

Determine plotting bounds:
xmin = min(X_ref(ROI)); xmax = max(X_ref(ROI));
ymin = min(Y_ref(ROI)); ymax = max(Y_ref(ROI));
Use [xmin-0.5, xmax+0.5], [ymin-0.5, ymax+0.5] for pixel-edge alignment.

Color scaling:
umax = max(abs(U(ROI)));
vmax = max(abs(V(ROI)));
Either unified scale m = max(umax, vmax); clim = [-m, m];
Or separate climU/climV.

Plot:

If overlaying on I_ref:
imshow(I_ref, []); hold on;
hU = imagesc([xmin xmax], [ymin ymax], U);
set(hU, 'AlphaData', ROI * alphaU);
axis image; set(gca,'YDir','reverse');
colormap(turbo); colorbar; caxis(climU);

Repeat for V (or separate figure).

(Optional) ROI boundary:
B = bwperim(ROI, 8); plot(X_ref(B), Y_ref(B), 'k.', 'MarkerSize', 1);

4.3 Complexity

O(HW) memory & time; fast for 1000×1000.

RENDERING ON DEFORMED IMAGE (DEFORMED DOMAIN)

We offer two routes:

5.A Route A: Warp-based (backward mapping / imwarp)

Idea: Use the same geometric mapping to warp I_ref→I_def and simultaneously warp U, V, and ROI to the deformed domain. Then render U/V (now U_def/V_def) directly on I_def.

5.B Route B: Scatter-to-grid on deformed domain (forward mapping)

Idea: Compute deformed coordinates (X_def, Y_def) as scattered samples with associated values U, V; then interpolate these onto a regular grid aligned with I_def (or a chosen output lattice), producing U_on_def, V_on_def; overlay on I_def.

Both work; Route B is more general when you simply have (X_ref, Y_ref, U, V) and a measured I_def frame, without pre-defined warping operators. Route A is numerically safer against folding when using backward sampling.

ROUTE A (WARP-BASED / BACKWARD MAPPING) DETAILS

6.1 Preconditions

You have a displacement field compatible with MATLAB’s imwarp (R2020a+ supports displacement fields).

Define a displacement field D of size [H,W,2], where D(:,:,1)=U, D(:,:,2)=V follows the same pixel-axis conventions.

6.2 Steps

Build D = cat(3, U_fill, V_fill) where invalid (NaN) replaced by 0 or a neutral fill. Keep a separate ROI mask.

Warp reference image:
I_def_pred = imwarp(I_ref, D, 'FillValues', 0, 'SmoothEdges', true); % optional

Warp U, V, ROI “as images” with the same D:
U_def = imwarp(U_fill, D, 'FillValues', NaN);
V_def = imwarp(V_fill, D, 'FillValues', NaN);
ROI_def = imwarp(double(ROI), D, 'FillValues', 0) > 0.5; % nearest/bilinear as needed

Render:
imshow(I_def, []); hold on; % or I_def_pred if I_def missing
imagesc(U_def, 'XData',[0.5 W+0.5], 'YData',[0.5 H+0.5], 'AlphaData', ROI_def*alpha);
axis image; set(gca,'YDir','reverse'); colormap(turbo); colorbar; caxis(climU);
Repeat for V with same axes & clim if unified.

6.3 Pros/Cons

Pros: Single interpolation path; consistent mapping; robust to moderate folding (backward sampling).

Cons: Requires imwarp-compatible mapping and careful sign/convention; needs decisions for NaN fills.

ROUTE B (SCATTER-TO-GRID ON DEFORMED DOMAIN) DETAILS

7.1 Core Idea

Convert (X_ref, Y_ref, U, V) to scattered samples on deformed coordinates:
X_def = X_ref + U; Y_def = Y_ref + V (only on ROI).

Build scatteredInterpolant for U and V defined on (X_def, Y_def).

Evaluate on a target regular grid aligned to I_def (pixel centers).

Overlay heatmaps on I_def using Alpha masking to hide outside/holes.

7.2 Steps

ROI = ~isnan(X_ref)&~isnan(Y_ref)&~isnan(U)&~isnan(V).

Scattered samples:
xS = X_def(ROI) = X_ref(ROI)+U(ROI);
yS = Y_def(ROI) = Y_ref(ROI)+V(ROI);
uS = U(ROI); vS = V(ROI);

Choose target grid:
If I_def exists:
H,W = size(I_def);
x-range: [0.5, W+0.5]; y-range: [0.5, H+0.5].
[xg, yg] = meshgrid(0.5+(1:W), 0.5+(1:H));
Else:
Use bounding box of (xS, yS), set desired resolution (≈ bounding box size).

Interpolants:
Fu = scatteredInterpolant(xS, yS, uS, 'linear', 'none');
Fv = scatteredInterpolant(xS, yS, vS, 'linear', 'none');
U_on_def = Fu(xg, yg); V_on_def = Fv(xg, yg);

Deformed ROI (for clean Alpha):
Fm = scatteredInterpolant(xS, yS, ones(size(xS)), 'nearest', 'none');
ROI_def = ~isnan(Fm(xg, yg));

Color scaling:
m = max( max(abs(uS)), max(abs(vS)) ); clim = [-m, m] or separate.

Render:
imshow(I_def, []); hold on; % if available
imagesc([xmin xmax], [ymin ymax], U_on_def, 'AlphaData', ROI_def*alpha);
axis image; set(gca,'YDir','reverse');
colormap(turbo); colorbar; caxis(clim);
Repeat for V.

7.3 Performance Notes

Triangulation cost ~O(N log N), N≈#ROI pixels. For 1000×1000 dense ROI it’s large but often feasible.

If memory/time is tight:

Pre-subsample ROI (stride 2–4).

Blockwise evaluation (tile xg/yg).

Prefer 'linear' over 'natural'.

Interpolate only within the convex hull; ExtrapolationMethod='none'.

EDGE CASES & NUMERICAL PITFALLS

8.1 NaN Holes

Keep NaNs through Alpha masking. For Route B, extrapolation='none' ensures holes remain transparent.

ROI_def derived via Fm (nearest) helps create a crisp display mask on deformed domain.

8.2 Folding / Non-injective Mappings

Serious folding causes one-to-many or gaps in forward mapping (Route B). Visual artifacts may occur.

Prefer backward mapping (Route A) when folding is significant.

For visualization (not strict vector-tensor transport), treating U,V as scalar fields is acceptable.

8.3 Coordinate Alignment

Always set axis image and YDir='reverse'.

Always specify XData/YData extents for imagesc to align pixel edges (±0.5 convention).

8.4 Color Normalization

For robust visualization under outliers, use percentiles (e.g., 1–99%) instead of absolute max.

Consider unified caxis for U and V to aid comparison.

8.5 Very Large Domains

Use downsampling, ROI cropping, or multi-resolution rendering.

Consider GPU acceleration for scatteredInterpolant alternatives (not native in base MATLAB).

PUBLIC API (FOR THE AI AGENT TO IMPLEMENT/MODIFY)

9.1 Function: plotHeatmapOnReference
Signature:
[figU, figV] = plotHeatmapOnReference(I_ref, X_ref, Y_ref, U, V, opts)

Required:

X_ref, Y_ref, U, V (HxW).
Optional:

I_ref (can be []).

opts struct fields:

alphaU, alphaV: transparency (0–1), default 1.0.

unifiedCLim: true/false (default true).

climU, climV: [min max] or []; if empty, auto from data or unified.

showROIBoundary: true/false (default false).

cmap: e.g., 'turbo'.

titlePrefix: char.
Returns:

figU, figV: figure handles.

Behavior:

Render U and V heatmaps on reference domain bounds using imagesc + AlphaData=ROI.

If I_ref provided: overlay on I_ref; else render on blank axes with correct coords.

9.2 Function: plotHeatmapOnDeformed_Scatter (Route B)
Signature:
[figU, figV] = plotHeatmapOnDeformed_Scatter(I_def, X_ref, Y_ref, U, V, opts)

Required:

X_ref, Y_ref, U, V.
Optional:

I_def (can be []).

opts struct fields:

interpMethod: 'linear'|'natural' (default 'linear').

extrap: 'none'|'nearest' (default 'none').

targetSize: [H W] or []; if empty and I_def exists, use size(I_def), else use bounding box rounded to integer size.

alpha: 0–1 (default 0.65 if I_def exists, else 1.0).

unifiedCLim: true/false (default true).

clim: [min max] or [].

subsampleStride: integer ≥1 (default 1). If >1, subsample ROI points before building interpolants.

showROIBoundary: true/false (default false, boundary in deformed domain via triangulation edges optional).

cmap, titlePrefix.

Returns:

figU, figV.

Behavior:

Compute X_def, Y_def on ROI; (optionally) subsample.

Build Fu/Fv; evaluate on target grid; build ROI_def via nearest mask Fm.

Render U_on_def/V_on_def over I_def with AlphaData=ROI_def.

9.3 Function: plotHeatmapOnDeformed_Warp (Route A)
Signature:
[figU, figV] = plotHeatmapOnDeformed_Warp(I_def, I_ref, U, V, ROI, opts)

Required:

U, V, ROI (HxW).
Optional:

I_def, I_ref.

opts struct fields:

fillInvalid: value for NaNs in U/V when forming D (default 0).

warpOptions: name-value for imwarp (e.g., 'FillValues', 0).

unifiedCLim, clim, alpha, cmap, titlePrefix.

Behavior:

Build D = cat(3, U_fill, V_fill); warp U/V/ROI (and optionally I_ref) to deformed domain.

Overlay on I_def if provided, else on warped reference frame.

Render with AlphaData=ROI_def.

REFERENCE PSEUDOCODE (MINIMAL)

10.1 Reference Domain

ROI = ~isnan(X_ref)&~isnan(Y_ref)&~isnan(U)&~isnan(V)

[xmin,xmax,ymin,ymax] from ROI

Set clim(s)

imshow(I_ref,[]) if provided; hold on

h = imagesc([xmin xmax], [ymin ymax], U); set(h, 'AlphaData', ROI*alphaU)

axis image; set(gca,'YDir','reverse'); colormap(turbo); colorbar; caxis(climU)

Repeat for V.

10.2 Deformed Domain (Route B)

ROI as above

xS = X_ref(ROI)+U(ROI); yS = Y_ref(ROI)+V(ROI)

uS = U(ROI); vS = V(ROI)

Build Fu/Fv with ('linear','none')

Define [xg,yg] from I_def size or bounding box

U_on_def = Fu(xg,yg); V_on_def = Fv(xg,yg)

ROI_def via Fm = scatteredInterpolant(xS,yS,ones,'nearest','none')

imshow(I_def,[]) if provided; hold on

imagesc(U_on_def, 'XData',[xmin xmax], 'YData',[ymin ymax], 'AlphaData', ROI_def*alpha)

axis image; set(gca,'YDir','reverse'); colormap(turbo); colorbar; caxis(clim)

Repeat for V.

10.3 Deformed Domain (Route A)

U_fill/V_fill = U/V with NaNs→0; D=cat(3,U_fill,V_fill)

U_def = imwarp(U_fill, D, 'FillValues', NaN)

ROI_def = imwarp(double(ROI), D, 'FillValues', 0) > 0.5

imshow(I_def,[]); hold on

imagesc(U_def, 'AlphaData', ROI_def*alpha); axis image; set(gca,'YDir','reverse')

colormap(turbo); colorbar; caxis(clim)

Repeat for V.

CONFIGURATION KNOBS (FOR AGENT)

unifiedCLim: bool; if true, caxis shared by U/V ([-m,m]); else separate.

clim: explicit [lo hi]; supports percentile-based auto (e.g., [p1, p99]).

alpha: 0–1; default 0.65 when overlaying on image.

interpMethod (Route B): 'linear' (fast) vs 'natural' (smooth).

subsampleStride (Route B): 1 (dense) to 4+ (lighter).

targetSize (Route B): match I_def or custom grid.

fillInvalid (Route A): numeric fill for NaNs when building D.

showROIBoundary: bool; boundary dot size.

cmap: default 'turbo'.

titlePrefix: char.

VALIDATION & TESTS

12.1 Synthetic Sanity Test

Create a small reference grid (e.g., 64×64) with a circular ROI (others NaN).

Define U,V as a smooth field (e.g., rigid translation + small rotation).

Render reference-domain heatmaps; verify positions & signs.

Build I_def by warping I_ref with same D (Route A).

Render deformed-domain via Route A & Route B; visually compare overlays and ensure consistency.

12.2 Performance Test

Use 1024×1024 ROI with random holes.

Route B: test subsampleStride ∈ {1,2,4}, measure time & memory.

Ensure no crash; visual check: holes remain transparent; edges not ragged.

12.3 Folding Test (Advanced)

Create an exaggerated local shear to induce near-folding.

Compare Route A (backward) vs Route B (forward) for artifacts; ensure doc notes visible differences.

COMMON PITFALLS

Forgetting set(gca,'YDir','reverse') ⇒ vertically flipped overlays.

Misaligned extents: always pass XData/YData to imagesc to adhere to pixel-edge ±0.5 convention.

Using extrapolation beyond ROI: set 'none' to keep outside transparent.

Overly tight color limits ⇒ saturation; use robust (percentiles) or unified scaling.

Memory spikes with scatteredInterpolant at ~1e6 points; mitigate by subsampling/blocking.

Treating U,V as vectors that require rotation transport: for visualization, scalar transport is typically sufficient; document if true vector transport is required.

FUTURE EXTENSIONS

Vector-consistent transport (apply rotation part of deformation gradient).

GPU-based scatter-to-grid or tiled parallelization for very large fields.

Confidence/variance maps affecting AlphaData.

Multi-time rendering & flicker-free video generation.

END OF DOCUMENT